use curv::cryptographic_primitives::hashing::{Digest, DigestExt};
use curv::cryptographic_primitives::proofs::low_degree_exponent_interpolation::{
    LdeiProof, LdeiStatement, LdeiWitness,
};
use curv::cryptographic_primitives::proofs::ProofError;
use curv::cryptographic_primitives::secret_sharing::Polynomial;
use curv::elliptic::curves::*;
use curve25519_dalek::ristretto::RistrettoPoint;
use generic_array::GenericArray;
use serde::{Deserialize, Serialize};
use typenum::U64;

#[derive(Clone)]
pub struct SecretKey {
    sk: Scalar<Ristretto>,
    pk: Point<Ristretto>,
}

#[derive(Debug, Clone, PartialEq)]
pub struct PublicKey {
    pk: Point<Ristretto>,
}

/// Randomness generated by VDF
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(bound = "")]
pub struct VerifiableRandomness<H: Digest + Clone> {
    pub y: GenericArray<u8, U64>,
    pub proof: Proof<H>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(bound = "")]
pub struct Proof<H: Digest + Clone> {
    pub u: Point<Ristretto>,
    pub π: LdeiProof<Ristretto, H>,
}

impl SecretKey {
    pub fn generate() -> Self {
        let sk = Scalar::random();
        Self {
            pk: Point::generator() * &sk,
            sk,
        }
    }

    pub fn public_key(&self) -> PublicKey {
        PublicKey {
            pk: self.pk.clone(),
        }
    }

    pub fn eval<H: Digest<OutputSize = U64> + Clone>(
        &self,
        seed: &[u8],
    ) -> VerifiableRandomness<H> {
        let uʹ = ristretto_point_from_hash::<H>(seed);
        let u = &self.sk * &uʹ;

        let witness = LdeiWitness {
            w: Polynomial::from_coefficients(vec![self.sk.clone()]),
        };
        let stmt = LdeiStatement {
            alpha: vec![Scalar::from(1), Scalar::from(2)],
            g: vec![Point::generator().to_point(), uʹ],
            x: vec![self.public_key().pk, u.clone()],
            d: 0,
        };

        let π = LdeiProof::<_, H>::prove(&witness, &stmt).expect("stmt must be valid");

        let y = H::new().chain(seed).chain_point(&u).finalize();

        VerifiableRandomness {
            y,
            proof: Proof { u, π },
        }
    }
}

impl<H: Digest<OutputSize = U64> + Clone> VerifiableRandomness<H> {
    pub fn verify(&self, pk: &PublicKey, seed: &[u8]) -> Result<(), ProofError> {
        let uʹ = ristretto_point_from_hash::<H>(seed);
        let stmt = LdeiStatement {
            alpha: vec![Scalar::from(1), Scalar::from(2)],
            g: vec![Point::generator().to_point(), uʹ],
            x: vec![pk.pk.clone(), self.proof.u.clone()],
            d: 0,
        };
        self.proof.π.verify(&stmt)?;

        let y = H::new().chain(seed).chain_point(&self.proof.u).finalize();
        if y != self.y {
            return Err(ProofError);
        }

        Ok(())
    }

    pub fn randomness(&self) -> &GenericArray<u8, U64> {
        &self.y
    }
}

fn ristretto_point_from_hash<H: Digest<OutputSize = U64>>(bytes: &[u8]) -> Point<Ristretto> {
    let mut uniform_bytes = [0; 64];
    uniform_bytes.copy_from_slice(&H::new().chain(bytes).finalize());
    let point = RistrettoPoint::from_uniform_bytes(&uniform_bytes);
    Point::from_raw(curve_ristretto::RistrettoPoint::from_underlying(point))
        .expect("ristretto point is always valid")
}

#[cfg(test)]
mod test {
    use sha2::Sha512;

    use super::*;

    #[test]
    fn randomness_is_verifiable() {
        let sk = SecretKey::generate();
        let pk = sk.public_key();

        let seed = b"ZenGo";
        let rnd = sk.eval::<Sha512>(seed);
        rnd.verify(&pk, seed)
            .expect("failed to verify a correct randomness");
    }

    #[test]
    fn randomness_is_deterministic_for_fixed_seed() {
        let sk = SecretKey::generate();

        let seed = b"ZenGo";
        let rnd1 = sk.eval::<Sha512>(seed);
        let rnd2 = sk.eval::<Sha512>(seed);

        assert_eq!(rnd1.randomness(), rnd2.randomness());
    }

    #[test]
    fn detect_biased_randomness() {
        let sk = SecretKey::generate();
        let pk = sk.public_key();

        let seed = b"ZenGo";
        let mut rnd = sk.eval::<Sha512>(seed);
        rnd.y[34] += 1;

        rnd.verify(&pk, seed)
            .expect_err("proof passes for modified randomness");
    }
}
